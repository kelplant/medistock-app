package com.medistock.shared.data.repository

import app.cash.sqldelight.coroutines.asFlow
import app.cash.sqldelight.coroutines.mapToList
import com.medistock.shared.db.MedistockDatabase
import com.medistock.shared.domain.notification.NotificationEvent
import com.medistock.shared.domain.notification.NotificationPriority
import com.medistock.shared.domain.notification.NotificationType
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext

/**
 * Repository for managing local notification cache.
 * Notifications are generated by pg_cron on Supabase and synced to this local cache.
 * This repository handles the local SQLite storage only.
 */
class NotificationRepository(private val database: MedistockDatabase) {

    private val queries = database.medistockQueries

    // ==================== Read Operations ====================

    /**
     * Get all notifications.
     */
    suspend fun getAll(): List<NotificationEvent> = withContext(Dispatchers.Default) {
        queries.getAllNotifications().executeAsList().map { it.toModel() }
    }

    /**
     * Get notifications that haven't been displayed yet.
     */
    suspend fun getUndisplayed(): List<NotificationEvent> = withContext(Dispatchers.Default) {
        queries.getUndisplayedNotifications().executeAsList().map { it.toModel() }
    }

    /**
     * Get notifications that haven't been dismissed by the user.
     */
    suspend fun getUndismissed(): List<NotificationEvent> = withContext(Dispatchers.Default) {
        queries.getUndismissedNotifications().executeAsList().map { it.toModel() }
    }

    /**
     * Get a notification by ID.
     */
    suspend fun getById(id: String): NotificationEvent? = withContext(Dispatchers.Default) {
        queries.getNotificationById(id).executeAsOneOrNull()?.toModel()
    }

    /**
     * Get notifications by type.
     */
    suspend fun getByType(type: NotificationType): List<NotificationEvent> = withContext(Dispatchers.Default) {
        queries.getNotificationsByType(type.name).executeAsList().map { it.toModel() }
    }

    /**
     * Get notifications for a specific site.
     */
    suspend fun getBySite(siteId: String): List<NotificationEvent> = withContext(Dispatchers.Default) {
        queries.getNotificationsBySite(siteId).executeAsList().map { it.toModel() }
    }

    /**
     * Count undisplayed notifications (badge count).
     */
    suspend fun countUndisplayed(): Long = withContext(Dispatchers.Default) {
        queries.countUndisplayedNotifications().executeAsOne()
    }

    /**
     * Count undismissed notifications.
     */
    suspend fun countUndismissed(): Long = withContext(Dispatchers.Default) {
        queries.countUndismissedNotifications().executeAsOne()
    }

    // ==================== Write Operations ====================

    /**
     * Mark a notification as displayed (shown to user).
     */
    suspend fun markAsDisplayed(id: String) = withContext(Dispatchers.Default) {
        queries.markNotificationAsDisplayed(id)
    }

    /**
     * Mark a notification as dismissed (acknowledged by user).
     */
    suspend fun markAsDismissed(id: String) = withContext(Dispatchers.Default) {
        queries.markNotificationAsDismissed(id)
    }

    /**
     * Dismiss all notifications.
     */
    suspend fun dismissAll() = withContext(Dispatchers.Default) {
        queries.dismissAllNotifications()
    }

    /**
     * Insert a new notification.
     */
    suspend fun insert(event: NotificationEvent) = withContext(Dispatchers.Default) {
        queries.insertNotification(
            id = event.id,
            type = event.type.name,
            priority = event.priority.name,
            title = event.title,
            message = event.message,
            reference_id = event.referenceId,
            reference_type = event.referenceType,
            site_id = event.siteId,
            deep_link = event.deepLink,
            created_at = event.createdAt,
            is_displayed = if (event.isDisplayed) 1L else 0L,
            is_dismissed = if (event.isDismissed) 1L else 0L
        )
    }

    /**
     * Upsert a notification (preserve display/dismiss state if exists).
     * Use this when syncing from Supabase.
     */
    suspend fun upsert(event: NotificationEvent) = withContext(Dispatchers.Default) {
        queries.upsertNotification(
            id = event.id,
            type = event.type.name,
            priority = event.priority.name,
            title = event.title,
            message = event.message,
            referenceId = event.referenceId,
            referenceType = event.referenceType,
            siteId = event.siteId,
            deepLink = event.deepLink,
            createdAt = event.createdAt
        )
    }

    /**
     * Delete a notification.
     */
    suspend fun delete(id: String) = withContext(Dispatchers.Default) {
        queries.deleteNotification(id)
    }

    /**
     * Delete old notifications (cleanup).
     * @param olderThan Timestamp in milliseconds - delete notifications older than this.
     */
    suspend fun deleteOld(olderThan: Long) = withContext(Dispatchers.Default) {
        queries.deleteOldNotifications(olderThan)
    }

    /**
     * Delete all dismissed notifications.
     */
    suspend fun deleteDismissed() = withContext(Dispatchers.Default) {
        queries.deleteDismissedNotifications()
    }

    // ==================== Observe (Flow) ====================

    /**
     * Observe all notifications.
     */
    fun observeAll(): Flow<List<NotificationEvent>> {
        return queries.getAllNotifications()
            .asFlow()
            .mapToList(Dispatchers.Default)
            .map { list -> list.map { it.toModel() } }
    }

    /**
     * Observe undismissed notifications.
     */
    fun observeUndismissed(): Flow<List<NotificationEvent>> {
        return queries.getUndismissedNotifications()
            .asFlow()
            .mapToList(Dispatchers.Default)
            .map { list -> list.map { it.toModel() } }
    }

    // ==================== Extension Functions ====================

    /**
     * Convert SQLDelight generated class to domain model.
     */
    private fun com.medistock.shared.db.Notification_events_local.toModel(): NotificationEvent {
        return NotificationEvent(
            id = id,
            type = NotificationType.entries.find { it.name == type } ?: NotificationType.SYNC_PENDING,
            priority = NotificationPriority.fromString(priority),
            title = title,
            message = message,
            referenceId = reference_id,
            referenceType = reference_type,
            siteId = site_id,
            deepLink = deep_link,
            createdAt = created_at,
            isDisplayed = is_displayed == 1L,
            isDismissed = is_dismissed == 1L
        )
    }
}
